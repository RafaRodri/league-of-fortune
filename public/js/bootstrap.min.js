/ *!
* Bootstrap v4.3.1 (https://getbootstrap.com/)
* Copyright 2011-2019 Os Autores do Bootstrap (https://github.com/twbs/bootstrap/graphs/contributors)
* Licenciado sob o MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
* /
! function (t, e) {"objeto" == tipo de exportação && "undefined"! = tipo de módulo? e (exports, require ("jquery"), require ("popper.js")): "função" == typeof define && define.amd? define (["exportações", "jquery", "popper.js"], e): e ((t = t || self) .bootstrap = {}, t.jQuery, t.Popper)} (isto, função (t, g, u) {"usar estrito"; função i (t, e) {para (var n = 0; n <comprimento_e; n + +) {var i = e [n]; .enumerable = i.enumerable ||! 1, i.configurable =! 0, "valor" em i && (i.writable =! 0), Object.defineProperty (t, i.key, i)}} função s (t , e, n) {return e && i (t.prototipo, e), n && i (t, n), t} função l (o) {para (var t = 1; t <argumentos.length; t ++) {var r = null! = argumentos [t]? argumentos [t]: {}, e = Object.keys (r); "função" == typeof Object.getOwnPropertySymbols && (e = e.concat (Object.getOwnPropertySymbols (r) .filter (função (t) {return Object.getOwnPropertyDescriptor (r, t). numerável}))), e.forEach (função (t) {var e, n, i; e = o, i = Objeto.defineProperty (e, n, {valor: i, enumerável:! 0, configurável:! 0, gravável:! 0}): e [n] = i})} return o} g = g && g.hasOwnProperty ("padrão")? g.default: g, u = u & u.hasOwnProperty ("padrão")? u.default: u; var e = "transitionend"; função n (t) { var e = this, n =! 1; return g (this) .one (_. TRANSITION_END, function () {n =! 0}), setTimeout (função () {n || _.triggerTransitionEnd (e)}, t), this} var _ = {TRANSITION_END: ​​"bsTransitionEnd", getUID: function (t) {para (; t + = ~~ (1e6 * Math.random ()), document.getElementById (t);); }, getSelectorFromElement: function (t) {var e = t.getAttribute ("destino de dados"); if (! e || "#" === e) {var n = t.getAttribute ("href"); e = n && "# "! == n? n.trim ():" "} tente {return document.querySelector (e)? e: null} captura (t) {retorno nulo}}, getTransitionDurationFromElement: function (t) {if (! t) retorno 0; var e = g (t) .css ("duração de transição"), n = g (t) .css ("atraso de transição"), i = parseFloat (e), o = parseFloat (n ); return i || o? (e = e.split (",") [0], n = n.split (",") [0], 1e3 * (parseFloat (e) + parseFloat (n)) ): 0}, reflow: function (t) {retorno t.offsetHeight}, triggerTransitionEnd: function (t) {g (t) .trigger (e)}, supportsTransitionEnd: function () {retorno Boolean (e)}, isElement : function (t) {return (t [0] || t) .nodeType}, typeCheckConfig: function (t, e, n) {para (var i em n) if (Object.prototype.hasOwnProperty.call (n, i)) {var = n [i], r = e [i], s = r && _. isElement (r)? "elemento": (a = r, {}. toString.call (a) .match (/ \ s ([az] +) / i) [1] .toLowerCase ()); se (! new RegExp (o) .teste (s)) lançar novo erro (t.toUpperCase () + ': Opção "' + i + '" fornecido tipo "' + s + '" mas tipo esperado "' + o + '".')} var a}, findShadowRoot: function (t) {if (! document. documentElement.attachShadow) return null; if ("function"! = typeof t.getRootNode) retorna t instanceof ShadowRoot? t: t.parentNode? _. findShadowRoot (t.parentNode): nulo; var e = t.getRootNode (); return e instanceof ShadowRoot? e: null}}; g.fn.emulateTransitionEnd = n, g.event.special [_. TRANSITION_END] = {bindType: e, tipoDelegate: e, identificador: function (t) {if (g ( t.target) .é (this)) return t.handleObj.handler.apply (isto, argumentos)}}; var o = "alerta", r = "bs.alert", a = "." + r, c = g.fn [o], h = {FECHAR: "fechar" + a, FECHADO: "fechado" + a, CLICK_DATA_API: "clique" + a + ". data-api"}, f = "alerta", d = "fade", m = "show",p = function () {função i (t) {this._element = t} var t = i.prototype; retorno t.close = função (t) {var e = this._element; t && (e = this._getRootElement ( t)), this._triggerCloseEvent (e) .isDefaultPrevented () || this._removeElement (e)}, t.dispose = function () {g.removeData (this._element, r), this._element = null}, t._getRootElement = function (t) {var e = _. getSelectorFromElement (t), n =! 1; return e && (n = document.querySelector (e)), n || (n = g (t) .closest ( "." + f) [0]), n}, t._triggerCloseEvent = função (t) {var e = g.Evento (h.CLOSE); retorno g (t) .trigger (e), e}, t ._removeElement = function (e) {var n = this; if (g (e) .removeClass (m), g (e) .hasClass (d)) {var t = _. getTransitionDurationFromElement (e); g (e) .one (_. TRANSITION_END, função (t) {return n._destroyElement (e, t)}). emulateTransitionEnd (t)} else this._destroyElement (e)}, t._destroyElement = função (t) {g (t ) .detach (). trigger (h.CLOSED) .remove ()}, i._jQueryInterface = function (n) {retornar this.each (function () {var t = g (isto), e = t.data (r); e || (e = novo i (este), t.data (r , e)), "fechar" === n && e [n] (este)})}, i._handleDismiss = função (e) {função return (t) {t && t.preventDefault (), e.close (this)} }, s (i, nulo, [{key: "VERSION", get: function () {retorno "4.3.1"}}]), i} (); g (documento) .on (h.CLICK_DATA_API, ' [data-dismiss = "alerta"] ', p._handleDismiss (nova p)), g.fn [o] = p._jQueryInterface, g.fn [o] .Construtor = p, g.fn [o] .noConflict = function () {return g.fn [o] = c, p._jQueryInterface}; var v = "botão", y = "bs.button", E = "." + y, C = ". data-api ", T = g.fn [v], S =" ativo ", b =" btn ", eu =" foco ", D = '[data-toggle ^ =" botão "]', w = '[data- toggle = "botões"] ', A =' input: not ([type = "hidden"]) ',N = ". Ativo", O = ". Btn", k = {CLICK_DATA_API: "clique em" + E + C, FOCUS_BLUR_DATA_API: "foco" + E + C + "desfoque" + E + C ", P = função () {função n (t) {this._element = t} var t = n.prototipo; return t.toggle = função () {var t =! 0, e =! 0, n = g (this._element) .closest (w) [0]; if (n) {var i = this._element.querySelector (A); if (i) {if ("rádio" === i.type) if (i.checked && this._element.classList .contains (S)) t =! 1; else {var = n.querySelector (N); o && g (o) .removeClass (S)} se (t) {if (i.hasAtributo ("desativado") || n.hasAtributo ("desativado") || i.classList.contains ("desativado") || n.classList.contains ("desativado")) return; i.checked =! this._element.classList.contains (S) , g (i) .trigger ("alteração")} i.focus (), e =! 1}} e && this._element.setAttribute ("aria-pressed",! this._element.classList.contains (S)),t && g (this._element) .toggleClass (S)}, t.dispose = function () {g.removeData (this._element, y), this._element = null}, n._jQueryInterface = function (e) {retorne este .each (function () {var t = g (this) .data (y); t || (t = new n (this), g (this) .data (y, t)), "alternar" == = e & t [e] ()})}, s (n, nulo, [{key: "VERSION", get: function () {retorno "4.3.1"}}]), n} (); g (documento ). (k.CLICK_DATA_API, D, função (t) {t.preventDefault (); var e = t.target; g (e) .hasClass (b) || (e = g (e) .closest (O )), P._jQueryInterface.call (g (e), "alternar")}). On (k.FOCUS_BLUR_DATA_API, D, função (t) {var e = g (t.target) .closest (O) [0 ]; g (e) .toggleClass (Eu, / ^ foco (em)? $ /. teste (t.type))}), g.fn [v] = P._jQueryInterface, g.fn [v] .Construtor = P, g.fn [v] .noConflict = function () {retorno g.fn [v] = T, P.jQueryInterface}; var L = "carrossel", j = "bs.carossel", H = ". "+ j, R =". data-api ",x = g.fn [L], F = {intervalo: 5e3, teclado:! 0, slide:! 1, pausa: "pairar", quebra automática:! 0, toque:! 0}, U = {intervalo: "( number | boolean) ", keyboard:" boolean ", slide:" (booleano | string) ", pausa:" (string | boolean) ", wrap:" booleano ", touch:" booleano "}, W =" next " , q = "prev", M = "left", K = "right", Q = {SLIDE: "slide" + H, SLID: "deslizou" + H, KEYDOWN: "keydown" + H, MOUSE: "mouseenter "+ H, MOUSELEAVE:" mouseleave "+ H, TOUCHSTART:" touchstart "+ H, TOUCHMOVE:" touchmove "+ H, TOQUE:" touchend "+ H, POINTERDOWN:" ponteiro para ponteiro "+ H, POINTERUP:" ponteiro "+ H, DRAG_START: "dragstart" + H, LOAD_DATA_API: "carregar" + H + R, CLICK_DATA_API: "clique" + H + R}, B = "carrossel", V = "ativo", Y = "slide",z = "carrossel-item-right", X = "carrossel-item-left", $ = "carrossel-item-next", G = "carrossel-item-prev", J = "ponteiro-evento", Z = ".active", tt = ". active.carousel-item", et = ". item-carrossel", nt = ". item-carrossel img", ele = ". item-carrossel-próximo, .carousel-item- prev ", ot =". indicadores de carrossel ", rt =" [data-slide], [data-slide-to] ", st = '[passeio de dados =" carrossel "]', em = {TOUCH:" toque ", caneta:" caneta "}, lt = function () {função r (t, e) {this._items = null, this._interval = null, this._activeElement = null, this._isPaused =! 1, este ._isSliding =! 1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig (e), this._element = t, this._indicatorsElement = this._element.querySelector (ot), this._touchSupported = "ontouchstart"em document.documentElement || 0 <navigator.maxTouchPoints, this._pointerEvent = Booleano (window.PointerEvent || window.MSPointerEvent), this._addEventListeners ()} var t = r.prototype; retorno t.next = function () { this._isSliding || this._slide (W)}, t.nextWhenVisible = function () {! document.hidden && g (this._element) .is (": visible") && "oculto"! == g (this._element ) .css ("visibilidade") && this.next ()}, t.prev = function () {this._isSliding || this._slide (q)}, t.pause = function (t) {t || (isto ._isPaused =! 0), this._element.querySelector (it) && (_. triggerTransitionEnd (this._element), this.cycle (! 0)), clearInterval (this._interval), this._interval = null}, t .cycle = função (t) {t || (this._isPaused =! 1), this._interval && (clearInterval (this._interval), this._interval = null), this._config.interval &&! this._isPaused && (isto._interval = setInterval ((document.visibilityState? this.nextWhenVisible: this.next) .bind (this), this._config.interval))}, t.to = função (t) {var e = this; this._activeElement = this._element.querySelector (tt); var n = this._getItemIndex (this._activeElement); if (! (t> this._items.length-1 || t <0)) if (this._isSliding) g (este ._element) .one (Q.SLID, function () {return e.to (t)}); else {if (n === t) retorna this.pause (), void this.cycle (); var i = n <t? W: q; this._slide (i, this._items [t])}}, t.dispose = function () {g (this._element) .off (H), g.removeData (este ._element, j), this._items = null, this._config = null, this._element = nulo, this._interval = null, this._isPaused = nulo, this._isSliding = nulo, this._activeElement = nulo, este. _indicatorsElement = null}, t._getConfig = function (t) {retorno t = l ({}, F, t), _. tipoCheckConfig (L, t, U), t}, t._handleSwipe = function () {var t = Math.abs (this.touchDeltaX); if (! (t <= 40)) {var e = t / this.touchDeltaX; 0 <e&& this.prev (), e <0 && this.next ()}}, t._addEventListeners = function () {var e = isto; this._config.keyboard && g (this._element) .on (Q.KEYDOWN, function (t) {return e._keydown (t)}), "pairar" === this._config.pause && g (this._element) .on (Q.MOUSEENTER, function (t) {return e.pause (t)}). on (Q.MOUSELEAVE, function (t) {return e.cycle (t)}), this._config.touch && this._addTouchEventListeners ()}, t._addTouchEventListeners = function () {var n = isso; if (this._touchSupported) {var e = função (t) {n._pointerEvent && em [t.originalEvent.pointerType.toUpperCase ()]? n.touchStartX = t.originalEvent.clientX: n._pointerEvent || (n.touchStartX = t.originalEvent.touches [0] .clientX)}, i = função (t) {n._pointerEvent && em [t.originalEvent.pointerType.toUpperCase ()] && (n.touchDeltaX = t.originalEvent.clientX-n.touchStartX), n._handleSwipe (), "hover" === n._config.pause && (n.pause (), n.touchTimeout && clearTimeout (n.touchTimeout), n.touchTimeout = setTimeout (função (t) {return n. ciclo (t)}, 500 + n._config.interval)); g (this._element.querySelectorAll (nt)). on (Q.DRAG_START, função (t) {return t.preventDefault ()}), isto ._pointerEvent? (g (this._element) .on (Q.POINTERDOWN, função (t) {return e (t)}), g (este._element) .on (Q.POINTERUP, função (t) {return i (t)}), this._element.classList.add (J)): (g (this._element) .on (Q.TOUCHSTART, função (t) {retorno e (t)}), g (this._element ). (Q.TOUCHMOVE, function (t) {var e; (e = t) .originalEvent.touches && 1 <e.originalEvent.touches.length? n.touchDeltaX = 0: n.touchDeltaX = e.originalEvent.touches [ 0] .clientX -n.touchStartX}), g (this._element) .on (Q.TOUCHEND, função (t) {retorno i (t)}))}}, t._keydown = função (t) {se (! / input | textarea / i.test (t.target.tagName)) switch (t.which) {case 37: t.preventDefault (), this.prev (); quebra; caso 39: t.preventDefault (), this.next ()}}, t._getItemIndex = function (t) {retornar this._items = t && t.parentNode? []. slice.call (t.parentNode.querySelectorAll (et)): [], this._items.indexOf (t)}, t. _getItemByDirection = função (t, e) {var n = t === W, i = t === q, o = this._getItemIndex (e), r = this._items.length-1; if ((i && 0 = == o || n && o === r) &&! this._config.wrap) return e; var s = (o + (t === q? -1: 1))% this._items.length; retorno-1 === s? this._items [this._items.length-1]: this._items [s]}, t._triggerSlideEvent = função (t, e) {var n = this._getItemIndex (t), i = isto ._getItemIndex (this._element.querySelector (tt)), o = g.Event (Q.SLIDE, {relatedTarget: t, direção: e, de: i, para: n}); return g (this._element). disparador (o), o}, t._setActiveIndicatorElement = função (t) {if (this._indicatorsElement) {var e = []. slice.call (this._indicatorsElement.querySelectorAll (Z)); g (e) .removeClass (V); var n = this._indicatorsElement.children [this._getItemIndex (t)]; n && g (n) .addClass (V)}} , t._slide = função (t, e) {var n, i, o, r = isto, s = this._element.querySelector (tt), a = this._getItemIndex (s), l = e || s && this. _getItemByDirection (t, s), c = this._getItemIndex (l), h = Booleano (this._interval); se (o = t === W? (n = X, i = $, M) :( n = z, i = G, K), l && g (l) .hasClasse (V)) this._isSliding =! 1; else if (! this._triggerSlideEvent (l, o) .éDefaultPrevented () && s&&l) {this._isSliding =! 0, h && this.pause (), this._setActiveIndicatorElement (l); var u = g.Event (Q.SLID, {relatedTarget: l, direção: o, de: a, para: c}); if (g (este ._element) .hasClass (Y)) {g (l) .addClass (i), _. reflow (l), g (s) .addClass (n), g (l) .addClass (n); var f = parseInt (l.getAttribute ("data-interval"), 10); this._config.interval = f? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, f): this._config.defaultInterval || this._config.interval; var d = _. getTransitionDurationFromElement (s); g (s) .one (_. TRANSITION_END, function () {g (l) .removeClass (n + "" + i) .addClass (V), g (s) .removeClass (V + "" + i + "" + n), r._isSliding =! 1, setTimeout (function () {return g (r._element) .trigger (u)}, 0)}). emulateTransitionEnd (d)} mais g (s) .removeClass (V), g (l) .addClass (V) , this._isSliding =! 1, g (this._element) .trigger (u); h && this.cycle ()}}, r._jQueryInterface = função (i) {retornar this.each (function () {var t = g (this) .data (j), e = l ({}, F, g (this) .data ()); "objeto" == typeof i && (e = l ({}, e, i)); var n = "string" == typeof i? i: e.slide; if (t || (t = novo r (isto, e), g (isto) .data (j, t)), "número" == typeof i) t.to (i); else if ("string" == tipoof n) {if ("undefined "== typeof t [n]) lança new TypeError ('Nenhum método chamado' '+ n +'" '); t [n] ()} else e.interval && e.ride && (t.pause (), t.cycle ())})}, r._dataApiClickHandler = function (t) {var e = _. getSelectorFromElement (this); if (e) {var n = g (e) [0]; if (n && g (n) .hasClass (B)) {var i = l ({}, g (n) .data (), g (isto) .data ()), o = this.getAttribute ("deslizar os dados para"); o && (i .interval =! 1), r._jQueryInterface.call (g (n), i), o && g (n) .data (j) .a (o), t.preventDefault ()}}}, s (r, null , [{key: "VERSION", get: function () {retorno "4.3.1"}}, {key: "Padrão", get: function () {retorno F}}]), r} (); g (document) .on (Q.CLICK_DATA_API, rt, lt._dataApiClickHandler), g (janela) .on (Q.LOAD_DATA_API, function () {para (var t = []. slice.call (document.querySelectorAll (st) ), e = 0, n = t.length, e <n; e ++) {var i = g (t [e]); lt._jQueryInterface.call (i, i.data ())}}), g.fn [L] = lt._jQueryInterface, g.fn [L] .Construtor = lt, g.fn [L] .noConflict = function () {retorno g.fn [L] = x, lt._jQueryInterface}; var ct = "colapso", ht = "bs.colapso", ut = "." + ht, ft = g.fn [ct], dt = {alternar:! 0, pai: ""}, gt = {toggle: "booleano", pai: "(string | elemento)"}, _ t = {MOSTRAR: "mostrar" + ut, MOSTRADO: "mostrado" + ut, OCULTAR: "ocultar" + ut , HIDDEN: "oculto" + ut, CLICK_DATA_API: "clique" + ut + ". Data-api"}, mt = "mostrar", pt = "colapso", vt = "colapso", yt = "recolhido", Et = "largura", Ct = "altura", Tt = ". show, .collapsing", St = '[dados-toggle = "colapso"]', bt = function () {função a (e, t) {isto. _isTransitioning =! 1, this._element = e, this._config = this._getConfig (t), this._triggerArray = []. slice.call (documento.querySelectorAll ('[data-toggle = "colapso"] [href = "#' + e.id + '"], [data-toggle = "colapsar"] [data-alvo = "#' + e.id + '"] ')); para (var n = []. slice.call (document.querySelectorAll (St)), i = 0, o = n.length; i <o; i ++) {var r = n [i], s = _. getSelectorFromElement (r), a = []. slice.call (document.querySelectorAll (s)). filter (função (t) {retorno t === e}); null! == s && 0 <a.length && (this._selector = s, this._triggerArray.push (r))} this._parent = this._config.parent? this._getParent (): null, this._config.parent || this._addAriaAndCollapsedClass (this._element, this._triggerArray), this._config.toggle && this.toggle ()} var t = a.prototype; return t.toggle = função () {g (this._element) .hasClass (mt)? this.hide (): .show ()}, t.show = function () {var t, e, n = isso; if (! this._isTransitioning &&! g (this._element) .hasClass (mt) && (this._parent && 0 === (t = []. slice.call (this._parent.querySelectorAll (Tt)). filter (função (t) {retorno "string" == tipoof n._config.parent? t. getAttribute ("data-parent") === n._config.parent: t.classList.contains (pt)})). length && (t = null),! (t && (e = g (t) .not (isto ._selector) .data (ht)) && e._isTransitioning))) {var i = g.Event (_t.SHOW); se (g (this._element) .trigger (i),! i.isDefaultPrevented ()) { t && (a._jQueryInterface.call (g (t). não (this._selector), "ocultar"), e || g (t) .data (ht, nulo)); var o = this._getDimension (); g (this._element) .removeClass (pt) .addClass (vt), this._element.style [o] = 0, this._triggerArray.length && g (this._triggerArray) .removeClass (yt) .attr ("aria-expandido ",! 0), this.setTransitioning (! 0); var r =" deslocamento "+ (o [0] .toUpperCase () + o.slice (1)), s = _. GetTransitionDurationFromElement (isto._element); g (this._element) .one (_. TRANSITION_END, function () {g (n._element) .removeClass (vt) .addClass (pt) .addClass (mt), n._element.style [o] = "", n.setTransitioning (! 1), g (n._element) .trigger (_t.SHOWN)}). emulateTransitionEnd (s), this._element.style [o] = este._elemento [r] + " px "}}}, t.hide = function () {var t = isso; if (! this._isTransitioning && g (this._element) .hasClass (mt)) {var e = g.Event (_t.HIDE); se (g (this._element) .trigger (e),! e.isDefaultPrevented ()) {var n = this._getDimension (); this._element.style [n] = this._element.getBoundingClientRect () [n] + "px", _. reflow (this._element), g (this._element) .addClass (vt) .removeClass (pt) .removeClass (mt); var i = this._triggerArray.length; if (0 <i) para (var o = 0; o <i; o ++) {var r = this._triggerArray [o], s = _. getSelectorFromElement (r); if (null! == s) g ([]. slice.call ( document.querySelectorAll (s))). hasClass (mt) || g (r).addClass (yt) .attr ("aria-expandido",! 1)} this.setTransitioning (! 0); this._element.style [n] = ""; var a = _. getTransitionDurationFromElement (this._element); g (this._element) .one (_. TRANSITION_END, function () {t.setTransitioning (! 1), g (t._element) .removeClass (vt) .addClass (pt) .trigger (_t.HIDDEN)}). emulateTransitionEnd (a)}}}, t.setTransitioning = function (t) {this._isTransitioning = t}, t.dispose = function () {g.removeData (this._element, ht), this._config = null, este ._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null}, t._getConfig = function (t) {retorno (t = l ({}, dt, t)). toggle = Boolean (t.toggle), _. TypeCheckConfig (ct, t, gt), t}, t._getDimension = function () {retorno g (this._element) .hasClass (Et)? Et: Ct}, t._getParent = function () {var t, n = isto; _. isElement (this._config.parent)? (t = this._config.parent, "undefined"! = tipo de this._config.parent.jquery && (t = this._config.parent [0])): t = document.querySelector (this._config.parent); var e = '[data-toggle = "colapso"] [data-pai = "' + este ._config.parent + '"]', i = []. slice.call (t.querySelectorAll (e)); retorno g (i) .each (função (t, e) {n._addAriaAndCollapsedClass (a._getTargetFromElement (e ), [e])}), t}, t._addAriaAndCollapsedClass = function (t, e) {var n = g (t) .hasClass (mt); e.length &&g (e) .toggleClass (yt,! n) .attr ("aria-expandido", n)}, a._getTargetFromElement = função (t) {var e = _. getSelectorFromElement (t); retorno e? document.querySelector (e): null}, a._jQueryInterface = function (i) {return this.each (função () {var t = g (isto), e = t.data (ht), n = l ({}, dt, t.data (), "objeto" == typeof i && i? i: {}); if (! e && n.toggle && / show | hide / .test (i) && (n.toggle =! 1), e || (e = novo a (isto, n), t .data (ht, e)), "string "== typeof i) {if (" indefinido "== typeof e [i]) lança novo TypeError ('Nenhum método chamado' + i + '"'); e [i] ()}}}}, s (a, null, [{key: "VERSION", obter: function () {return "4.3.1"}}, {key: "Padrão", get: function () {return dt}}]), a} (); g (documento) .on (_t.CLICK_DATA_API, St, função (t) {"A" === t.currentTarget.tagName && t.preventDefault (); var n = g (isto), e = _. getSelectorFromElement (isto), i = []. slice.call (document.querySelectorAll (e)); g (i) .each (function () {var t = g (isto), e = t.data (ht)? " toggle ": n.data (); bt._jQueryInterface.call (t, e)})}), g.fn [ct] = bt._jQueryInterface, g.fn [ct] .Construtor = bt, g.fn [ ct] .noConflict = function () {retorno g.fn [ct] = ft, bt._jQueryInterface}; var = "dropdown", Dt = "bs.dropdown", wt = "." + Dt, At = " .data-api ", Nt = g.fn [It], Ot = new RegExp ("38 | 40 | 27 "), kt = {OCULTAR:" esconder "+ wt, HIDDEN:" oculto "+ peso, MOSTRAR:" mostrar "+ peso, MOSTRADO:" mostrado "+ peso, CLIQUE:" clique "+ peso , CLICK_DATA_API: "clique" + wt + At, KEYDOWN_DATA_API: "keydown" + wt + Em, KEYUP_DATA_API: "keyup" + wt + At}, Pt = "desativado", Lt = "show", jt = "dropup", Ht = "dropright", Rt = "dropleft", xt = "dropdown-menu-right", Ft = "posição-estática", Ut = '[data-toggle = "dropdown"]', Wt = ". ", qt =". menu suspenso ", Mt =". navbar-nav ", Kt =". menu suspenso .dropdown-item: não (.disabled): não (: desativado) ", Qt =" top- start ", Bt =" top-end ", Vt =" bottom-start ", Yt =" bottom-end ", zt =" início-direito ", Xt =" início-esquerdo ", $ t = {deslocamento: 0 , flip:! 0, limite: "scrollParent ", referência:" alternar ", exibir:" dinâmico "}, Gt = {deslocamento:" (número | cadeia | função) ", inverter:" booleano ", limite:" (string | elemento) ", referência:" (string | elemento) ", display:" string "}, Jt = function () {função c (t, e) {this._element = t, this._popper = null, this._config = this._getConfig (e) , this._menu = this._getMenuElement (), this._inNavbar = this._detectNavbar (), this._addEventListeners ()} var t = c.prototype; retorno t.toggle = function () {if (! this._element. disabled &&! g (this._element) .hasClass (Pt)) {var = c._getParentFromElement (this._element), e = g (this._menu) .hasClass (Lt); if (c._clearMenus (),!) e) {var n = {relatedTarget: this._element}, i = g.Event (kt.SHOW, n); se (g (t) .trigger (i),! i.isDefaultPrevented ()) {if (! this._inNavbar) {if ("undefined" == typeof u) lança novo TypeError ("Bootstrap 's dropdowns requerem Popper.js (https://popper.js.org/)");var o = this._element; "parent" === this._config.reference? o = t: _. isElement (this. _config.reference) && (o = this._config.reference, "undefined"! = tipo de this._config.reference.jquery && (o = this._config.reference [0])), "scrollParent"! == this._config .boundary && g (t) .addClass (Ft), this._popper = new u (o, this._menu, this._getPopperConfig ())} "ontouchstart" em document.documentElement && 0 === g (t) .closest (Mt) .length && g (document.body) .children (). on ("mouseover", nulo, g.noop), this._element.focus (), this._element.setAttribute ("aria-expandido",! 0), g (this._menu) .toggleClass (Lt), g (t) .toggleClass (Lt) .trigger (g.Event (kt.SHOWN, n))}}}}, t.show = function () {if (! (this._element.disabled || g (this._element) .hasClass (Pt) || g (this._menu).hasClass (Lt))) {var t = {relatedTarget: this._element}, e = g.Event (kt.SHOW, t), n = c._getParentFromElement (this._element); g (n) .trigger (e ), e.isDefaultPrevented () || (g (this._menu) .toggleClass (Lt), g (n) .toggleClass (Lt) .trigger (g.Event (kt.SHOWN, t)))}}, t .hide = function () {if (! this._element.disabled &&! g (this._element) .hasClass (Pt) && g (this._menu) .hasClass (Lt)) {var t = {relatedTarget: this._element} , e = g.Event (kt.HIDE, t), n = c._getParentFromElement (this._element); g (n) .trigger (e), e.isDefaultPrevented () || (g (this._menu). toggleClass (Lt), g (n) .toggleClass (Lt) .trigger (g.Event (kt.HIDDEN, t)))}}, t.dispose = function () {g.removeData (this._element, Dt) , g (this._element) .off (wt), this._element = nulo, (this._menu = null)! == this._popper && (this._popper.destroy (), this._popper = null)}, t .update = function () {this._inNavbar = this._detectNavbar (), null! == this._popper && este._popper.scheduleUpdate ()}, t._addEventListeners = function () {var e = this; g (this._element) .on (kt.CLICK, função (t) {t.preventDefault (), t.stopPropagation (), e.toggle ()})}, t._getConfig = function (t) {retorno t = l ({}, this.constructor.Default, g (this._element) .data (), t), _. typeCheckConfig ( It, t, this.constructor.DefaultType), t}, t._getMenuElement = function () {se (! This._menu) {var t = c._getParentFromElement (this._element); t && (this._menu = t. querySelector (qt)}} retornar this._menu}, t._getPlacement = function () {var t = g (this._element.parentNode), e = Vt; retorno t.hasClass (jt)? (e = Qt, g (this._menu) .hasClass (xt) && (e = Bt)): t.hasClass (Ht)? e = zt: t.hasClass (Rt)? e = Xt: g (this._menu) .hasClass (xt ) && (e = Yt), e}, t._detectNavbar = function () {retornar 0 <g (this._element) .closest (". navbar"). comprimento}, t._getOffset = function () {var e = this, t = {}; return "function" == digite isso._config.offset? t.fn = função (t) {retorno t.offsets = l ({}, t.offsets, e._config.offset (t.offsets, e._element) || {}), t}: t.offset = this._config.offset, t}, t._getPopperConfig = function () {var t = {posicionamento: this._getPlacement (), modificadores: {deslocamento: this._getOffset (), flip: {ativado: este ._config.flip}, preventOverflow: {boundariesElement: this._config.boundary}}}; return "static" === this._config.display && (t.modifiers.applyStyle = {enabled:! 1}), t}, c._jQueryInterface = function (e) {retornar this.each (function () {var t = g (this) .data (Dt); if (t || (t = new c (isso, "objeto" == typeof e? e: null), g (isto) .data (Dt, t)), "string" == typeof e) {if ("indefinido" == typeof t [e]) lançar novo TypeError ('Nenhum método chamado "'+ e +'" '); t [e] ()}}}}, c._clearMenus = função (t) {if (! t || 3! == t.which && ("keyup"! == t .type || 9 === t.which)) para (var e = [].slice.call (document.querySelectorAll (Ut)), n = 0, i = e.length; n <i; n ++) {var = c._getParentFromElement (e [n]), r = g (e [n] ) .data (Dt), s = {relatedTarget: e [n]}; if (t && "clique" === t.type && (s.clickEvent = t), r) {var a = r._menu; if ( g (o) .hasClass (Lt) &&! (t && ("clique" === t.type && / input | textarea / i.test (nome.target.tagName) || "keyup" === t.type && 9 = == t.which) && g.contains (o, t.target))) {var l = g.Evento (kt.HIDE, s); g (o) .trigger (l), l.isDefaultPrevented () || ("ontouchstart" em document.documentElement && g (document.body) .children (). off ("mouseover", nulo, g.noop), e [n] .setAttribute ("aria-expandido", "falso"), g (a) .removeClass (Lt), g (o) .removeClass (Lt) .trigger (g.Event (kt.HIDDEN, s)))}}}}, c._getParentFromElement = function (t) {var, n = _. getSelectorFromElement (t); return n &&(e = document.querySelector (n)), e || t.parentNode}, c._dataApiKeydownHandler = function (t) {se ((/ input | textarea / i.test (t.target.tagName)?! === t.which || 27! == t.which && (40! == t.which && 38! == t.which || g (t.target) .closest (qt) .comprimento)): Ot.test (t.which)) && (t.preventDefault (), t.stopPropagation (), this.disabled &&! g (this) .hasClass (Pt))) {var e = c._getParentFromElement (this), n = g (e) .hasClass (Lt); if (n && (! n || 27! == t.which && 32! == t.which)) {var i = []. slice.call (e.querySelectorAll (Kt)) ; if (0! == i.length) {var o = i.indexOf (t.alvo); 38 === t.que && 0 <o && o-, 40 === t.que && o <i.length-1 && o ++, o <0 && (o = 0), i [o] .focus ()}} mais {if (27 === t.which) {var r = e.querySelector (Ut); g (r) .trigger (" focus ")} g (this) .trigger (" click ")}}}, s (c, nulo, [{key:" VERSION ", get: function () {retorno"4.3.1 "}}, {key:" Padrão ", get: function () {retorno $ t}}, {chave:" DefaultType ", get: function () {retorno Gt}}]), c} () ; g (documento) .on (kt.KEYDOWN_DATA_API, Ut, Jt._dataApiKeydownHandler) .on (kt.KEYDOWN_DATA_API, qt, Jt._dataApiKeydownHandler) .on (kt.CLICK_DATA_API + "" + kt.KEYUP_DATA_API, Jt._clearMenus) .em (kt.CLICK_DATA_API, Ut, função (t) {t.preventDefault (), t.stopPropagation (), Jt._jQueryInterface.call (g (isto), "toggle")}). on (kt.CLICK_DATA_API, Wt, function (t) {t.stopPropagation ()}), g.fn [It] = Jt._jQueryInterface, g.fn [É] .Construtor = Jt, g.fn [It] .noConflict = function () {retorno g .fn [It] = Nt, Jt._jQueryInterface}; var Zt = "modal", te = "bs.modal", ee = "." + te, ne = g.fn [Zt], ie = {pano de fundo: ! 0, teclado:! 0, foco:! 0, show:! 0}, oe = {pano de fundo: "(booleano | string)", teclado: "booleano", foco: "booleano", show:"boolean"}, re = {ESCONDER: "ocultar" + ee, HIDDEN: "oculto" + ee, SHOW: "mostrar" + ee, MOSTRADO: "mostrado" + ee, FOCUSIN: "focusin" + ee, RESIZE: "redimensionar" + ee, CLICK_DISMISS: "click.dismiss" + ee, KEYDOWN_DISMISS: "keydown.dismiss" + ee, MOUSEUP_DISMISS: "mouseup.dismiss" + ee, MOUSEDOWN_DISMISS: "mousedown.dismiss" + ee, CLICK_DATA_API: "clique em "+ ee +". data-api "}, se =" modal-dialog-scrollable ", ae =" modal-barra de rolagem-medida ", le =" modal-pano de fundo ", ce =" modal-aberto ", he =" fade ", ue =" show ", fe =". modal-dialog ", de =". corpo-modal ", ge = '[data-toggle =" modal "]', _ e = '[data-dismiss =" modal "]", me = ". top fixo, .fixado-bottom, .é-fixo, .sticky-top", pe = ". sticky-top",ve = function () {função o (t, e) {this._config = this._getConfig (e), this._element = t, this._dialog = t.querySelector (fe), this._backdrop = null, isso. _isShown =! 1, this._isBodyOverflowing =! 1, this._ignoreBackdropClick =! 1, this._isTransitioning =! 1, this._scrollbarWidth = 0} var t = o.prototype; retorno t.toggle = função (t) {retorno this._isShown? this.hide (): this.show (t)}, t.show = função (t) {var e = this; if (! this._isShown &&! this._isTransitioning) {g (this._element) .hasClass (he) && (this._isTransitioning =! 0); var n = g.Event (re.SHOW, {relatedTarget: t}); g (this._element) .trigger (n), this._isShown || n.isDefaultPrevented () || (this._isShown =! 0, this._checkScrollbar (), this._setScrollbar (), this._adjustDialog (), this._setEscapeEvent (), this._setResizeEvent (), g (this._element ). on (re.CLICK_DISMISS, _e, function (t) {return e.hide (t)}), g (this._dialog) .on (re.MOUSEDOWN_DISMISS, function () {g (e._element) .one (re.MOUSEUP_DISMISS, função (t) {g (t.target) .é (e._element) && (e._ignoreBackdropClick =! 0)})}), this._showBackdrop (function () {return e._showElement (t)}))}}, t.hide = function (t) {var e = this; if (t && t.preventDefault (), this._isShown &&! this._isTransitioning) {var n = g.Event ( re.HIDE); if (g (this._element) .trigger (n), this._isShown &&! n.isDefaultPrevented ()) {this._isShown =! 1; var i = g (this._element) .hasClass (ele if (i && (this._isTransitioning =! 0), this._setEscapeEvent (), this._setResizeEvent (), g (documento) .off (re.FOCUSIN), g (this._element) .removeClass (ue), g (this._element) .off (re.CLICK_DISMISS), g (this._dialog) .off (re.MOUSEDOWN_DISMISS), i) {var o = _. getTransitionDurationFromElement (this._element); g (this._element). um (_. TRANSITION_END, função (t) {return e._hideModal (t)}). emulateTransitionEnd (o)} else this._hideModal ()}}}, t.dispose = function () {[window, this._element, this._dialog] .forCada (função (t) {retorno g (t) .off (ee)}), g (documento) .off (re.FOCUSIN), g.removeData (this._element, te), this._config = null, this._element = nulo, this._dialog = null, this._backdrop = nulo, this._isShown = null, this._isBodyOverflowing = nulo, this._ignoreBackdropClique = null, this._isTransitioning = null, this._scrollbarWidth = null}, t.handleUpdate = function () {this._adjustDialog ()}, t._getConfig = function (t) {retorno t = l ({}, ou seja, t), _. typeCheckConfig (Zt, t, oe), t}, t._showElement = função (t) {var e = isso, n = g (this._element) .hasClass (ele); this._element.parentNode && this ._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild (this._element), this._element.style.display = "bloco", this._element.removeAttribute ("aria-hidden"), this._element.setAttribute ("aria-modal",! 0), g (this._dialog).hasClass (se)? this._dialog.querySelector (de) .scrollTop = 0: this._element.scrollTop = 0, n && _. reflow (this._element), g (this._element) .addClass (ue), this._config .focus && this._enforceFocus (); var i = g.Evento (re.SHOWN, {relatedTarget: t}), o = função () {e._config.focus && e._element.focus (), e._isTransitioning =! 1, g (e._element) .trigger (i)}; if (n) {var r = _. getTransitionDurationFromElement (this._dialog); g (this._dialog) .one (_. TRANSITION_END, o) .emulateTransitionEnd (r) } mais o ()}, t._enforceFocus = function () {var e = this; g (documento) .off (re.FOCUSIN) .on (re.FOCUSIN, function (t) {documento! == t.target && e ._element! == t.target && 0 === g (e._element) .has (t.target) .length && e._element.focus ()})}, t._setEscapeEvent = function () {var e = isso; ._isShown && this._config.keyboard? g (this._element) .on (re.KEYDOWN_DISMISS, função (t) {27 === t.which &&(t.preventDefault (), e.hide ())}): this._isShown || g (this._element) .off (re.KEYDOWN_DISMISS)}, t._setResizeEvent = function () {var e = isto; ._isShown? g (janela) .on (re.RESIZE, function (t) {return e.handleUpdate (t)}): g (janela) .off (re.RESIZE)}, t._hideModal = function () { var t = this; this._element.style.display = "nenhum", this._element.setAttribute ("aria-hidden",! 0), this._element.removeAttribute ("aria-modal"), this._isTransitioning = ! 1, this._showBackdrop (function () {g (document.body) .removeClass (ce), t._resetAdjustments (), t._resetScrollbar (), g (t._element) .trigger (re.HIDDEN)}) }, t._removeBackdrop = function () {this._backdrop && (g (this._backdrop) .remove (), this._backdrop = null)}, t._showBackdrop = função (t) {var e = isto, n = g (this._element) .hasClass (he)? he: ""; if (this._isShown && this._config.backdrop) {if (this._backdrop = documento.createElement ("div"), this._backdrop.className = le, n && this._backdrop.classList.add (n), g (this._backdrop) .appendTo (document.body), g (this._element) .on (re .CLICK_DISMISS, function (t) {e._ignoreBackdropClick? E._ignoreBackdropClick =! 1: t.target === t.currentTarget && ("static" === e._config.backdrop? E._element.focus (): e .hide ())}), n && _. reflow (this._backdrop), g (this._backdrop) .addClass (ue), t) return; if (! n) retorna void t (); var i = _. getTransitionDurationFromElement (this._backdrop); g (this._backdrop) .one (_. TRANSITION_END, t) .emulateTransitionEnd (i)} else if (! this._isShown && this._backdrop) {g (this._backdrop) .removeClass (ue) ; var o = função () {e._removeBackdrop (), t && t ()}; if (g (this._element) .hasClass (he)) {var r = _. getTransitionDurationFromElement (this._backdrop); g (isto. _backdrop) .one (_. TRANSITION_END, o).emulateTransitionEnd (r)} mais o ()} else t && t ()}, t._adjustDialog = function () {var t = this._element.scrollHeight> document.documentElement.clientHeight;! this._isBodyOverflowing && t && (this._element.style. paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing &&! t && (this._element.style.paddingRight = this._scrollbarWidth + "px")}, t._resetAdjustments = function () {this._element.style.paddingLeft = " ", this._element.style.paddingRight =" "}, t._checkScrollbar = function () {var t = document.body.getBoundingClientRect (); this._isBodyOverflowing = t.left + t.right <window.innerWidth, este ._scrollbarWidth = this._getScrollbarWidth ()}, t._setScrollbar = function () {var o = this; if (this._isBodyOverflowing) {var t = []. slice.call (document.querySelectorAll (eu)), e = [] .slice.call (document.querySelectorAll (pe)); g (t).each (função (t, e) {var n = e.style.paddingRight, i = g (e) .css ("padding-right"); g (e) .data ("padding-right", n). css ("padding-right", parseFloat (i) + o._scrollbarWidth + "px")}), g (e) .each (função (t, e) {var n = e.style.marginRight, i = g ( e) .css ("margin-right"); g (e) .data ("margin-right", n) .css ("margem-direita", parseFloat (i) -o._scrollbarWidth + "px")}) ; var n = document.body.style.paddingRight, i = g (document.body) .css ("preenchimento-à direita"); g (document.body) .data ("preenchimento-à direita", n) .css ( "padding-right", parseFloat (i) + this._scrollbarWidth + "px")} g (document.body) .addClass (ce)}, t._resetScrollbar = function () {var t = []. slice.call ( document.querySelectorAll (me)); g (t) .each (função (t, e) {var n = g (e) .data ("preenchimento-à direita"); g (e) .removeData ("padding-right "), e.style.paddingRight = n || ""}); var e = []. slice.call (document.querySelectorAll ("+ pe)); g (e) .each (função (t, e) {var n = g ( e) .data ("margin-right"); "indefinido"! = typeof n && g (e) .css ("margin-right", n) .removeData ("margin-right")}); var n = g ( document.body) .data ("padding-right"); g (document.body) .removeData ("padding-right"), document.body.style.paddingRight = n || ""}, t._getScrollbarWidth = function () {var t = document.createElement ("div"); t.className = ae, document.body.appendChild (t); var e = t.getBoundingClientRect (). largura-t.clientWidth; retorno document.body. removeChild (t), e}, o._jQueryInterface = function (n, i) {retornar this.each (function () {var t = g (this) .data (te), e = l ({}, ou seja, g (this) .data (), "objeto" == typeof n && n? n: {}); if (t || (t = novo o (isto, e), g (isto) .data (te, t) ), "string "== typeof n) {if (" indefinido "== typeof t [n]) lançar novo TypeError ('Nenhum método chamado' + n + '"'); t [n] (i)} else e.show && t .show (i)})}, s (o, nulo, [{key: "VERSION", get: function () {retorno "4.3.1"}}, {key: "Default", get: function () {return ie}}]), o} (); g (documento) .on (re.CLICK_DATA_API, ge, função (t) {var e, n = isso, i = _. getSelectorFromElement (this); i && (e = document.querySelector (i)); var o = g (e) .data (te)? "alternar": l ({}, g (e) .data (), g (este) .data ()); "A"! == this.tagName && "AREA"! == this.tagName || t.preventDefault (); var r = g (e) .one (re.SHOW, função (t) {t.isDefaultPrevented () || r.one (re.HIDDEN, function () {g (n) .is (": visible") && n.focus ()})}); ve._jQueryInterface.call (g (e), o, este )}), g.fn [Zt] = ve._jQueryInterface, g.fn [Zt] .Construtor = ve, g.fn [Zt].noConflict = function () {return g.fn [Zt] = ne, ve._jQueryInterface}; var ye = ["fundo", "citar", "href", "itemtype", "longdesc", "poster", " src "," xlink: href "], Ee = {" * ": [" classe "," dir "," id "," lang "," papel ", / ^ aria - [\ w -] * $ / i], a: ["alvo", "href", "título", "rel"], área: [], b: [], br: [], col: [], código: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "alt", "título", "largura", "altura"], li: [], ol: [], p: [], pre: [], s: [], pequeno: [ ], span: [], sub: [], sup: [], forte: [], u: [], ul: []}, Ce = / ^ (? :( ?: https? | mailto | ftp | tel | file): | [^ &: /? #] * (?: [/? #] | $)) / gi, Te = / ^ dados :( ?: image \ / (?: bmp | gif | jpeg | jpg | png | tiff | webp) | video \ / (?: mpeg | mp4 | ogg | webm) | audio \ / (?:mp3 | oga | ogg | opus)); base64, [a-z0-9 + /] + = * $ / i; função Se (t, s, e) {se (0 = t.length) retornar t ; if (e && "function" == typeof e) retorna e (t); para (var n = (new window.DOMParser) .parseFromString (t, "text / html"), a = Objeto.chave (s), l = []. slice.call (n.body.querySelectorAll ("*")), i = função (t, e) {var n = l [t], i = n.nodeName.toLowerCase (); if ( -1 === a.indexOf (n.nodeName.toLowerCase ())) return n.parentNode.removeChild (n), "continuar"; var o = []. Slice.call (n.atributos), r = [ ] .catcat (s ["*"] || [], s [i] || []); o.forEach (função (t) {(função (t, e) {var n = t.nodeName.toLowerCase (); if (-1! == e.indexOf (n)) return-1 === ye.indexOf (n) || Booleano (t.nodeValue.match (Ce) || t.nodeValue.match (Te )) para (var i = e.filter (função (t) {retorno t instanceof RegExp}), o = 0, r = i.length, o <r; o ++) if (n.match (i [o] )) return! 0; return! 1}) (t, r) || n.removeAttribute (t.nodeName)})}, o = 0,r = l.length; o <r> o ++) i (o); retorno n.body.innerHTML} var be = "tooltip", ou seja, "bs.tooltip", De = "." + Ou seja, nós = g .fn [ser], Ae = "bs-tooltip", Ne = novo RegExp ("(^ | \\ s)" + Ae + "\\ S +", "g"), Oe = ["sanitizar", "lista branca" "," sanitizeFn "], ke = {animação:" booleano ", modelo:" string ", título:" (string | elemento | função) ", trigger:" string ", delay:" (número | objeto) ", html: "boolean", seletor: "(string | boolean)", posicionamento: "(string | function)", deslocamento: "(número | string | função)", container: "(string | elemento | booleano)", fallbackPlacement: "(string | array)", limite: "(string | elemento)", sanitize: "booleano", sanitizeFn: "(função | nulo)", whiteList: "objeto"}, Pe = {AUTO: "auto ", TOP:" top ", DIREITA:" right ", BOTTOM:" bottom ", ESQUERDA:" esquerda "}, Le = {animação:! 0, modelo: '<div class =" tooltip "role =" tooltip "> <div class =" arrow "> </ div> <div classe =" tooltip-inner "> </ div> </ div> ', disparador:" foco em foco ", título:" ", atraso: 0, html:! 1, seletor:! 1, posicionamento: "top", deslocamento: 0, container:! 1, fallbackPlacement: "flip", limite: "scrollParent", sanitize:! 0, sanitizeFn: null, whiteList: Ee} , je = "show", He = "out", Re = {ocultar: "esconder" + De, HIDDEN: "oculto" + De, SHOW: "mostrar" + De, MOSTRADO: "mostrado" + De, INSERIDO: "inserido" + De, CLIQUE: "clique" + De, FOCUSIN: "focusin" + De, FOCUSOUT: "focusout" + De, MOUSEENTER: "mouseenter "+ De, MOUSELEAVE:" ratoeira "+ De}, xe =" enfraquecer ", Fe =" mostrar ", Ue =". tooltip-inner ", Nós =". arrow ", qe =" pairar ", Me = "foco", Ke = "click", Qe = "manual", Be = function () {função i (t, e) {if ("indefinido" == typeof u) lança novo TypeError ("Tooltips do Bootstrap requerem Popper. js (https://popper.js.org/)");this._isEnabled=!0,this._timeout=0,this._hoverState=""this._activeTrigger={},this._popper=null, this .element = t, this.config = this._getConfig (e), this.tip = nulo, this._setListeners ()} var t = i.prototype; retorno t.enable = function () {this._isEnabled =! 0 }, t.disable = function () {this._isEnabled =! 1}, t.toggleEnabled = function () {this._isEnabled =! this._isEnabled}, t.toggle = função (t) {if (this._isEnabled ) if (t) {var e = this.constructor.DATA_KEY, n = g (t.currentTarget).dados (e); n || (n = new this.constructor (t.currentTarget, this._getDelegateConfig ()), g (t.currentTarget) .data (e, n)), n._activeTrigger.click =! n ._activeTrigger.click, n._isWithActiveTrigger ()? n._enter (nulo, n): n._leave (nulo, n)} mais {if (g (this.getTipElement ()). hasClass (Fe)) return anular esta ._leave (null, this); this._enter (nulo, isso)}}, t.dispose = function () {clearTimeout (this._timeout), g.removeData (this.element, this.constructor.DATA_KEY), g (this.element) .off (this.constructor.EVENT_KEY), g (this.element) .closest (".modal") .off ("hide.bs.modal"), this.tip && g (this.tip). remove (), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null)! == this._popper && this._popper.destroy (), this._popper = null, isto. element = null, this.config = null, this.tip = null}, t.show = function () {var e = isto; if ("nenhum" === g (this.element).css ("display")) throw new Erro ("Por favor use show em elementos visíveis"); var t = g.Event (this.constructor.Event.SHOW); if (this.isWithContent () && this._isEnabled) {g (this.element) .trigger (t); var n = _. findShadowRoot (this.element), i = g.contains (nulo! == n? n: this.element.ownerDocument.documentElement, this.element); if (t.isDefaultPrevented () ||! i) return; var o = this.getTipElement (), r = _. getUID (this.constructor.NAME); o.setAttribute ("id", r), this.element .setAttribute ("aria-describedby", r), this.setContent (), this.config.animation && g (o) .addClass (xe); var s = "função" == typeof this.config.placement? this.config .placement.call (this, o, this.element): this.config.placement, a = this._getAttachment (s); this.addAttachmentClass (a); var l = this._getContainer (); g (o). data (this.constructor.DATA_KEY, this), g.contains (this.element.ownerDocument.documentElement, this.tip) || g (o) .appendTo (l), g (este.elemento) .trigger (this.constructor.Event.INSERTED), this._popper = new u (this.element, o , {placement: a, modificadores: {offset: this._getOffset (), flip: {behavior: this.config.fallbackPlacement}, seta: {element: We}, preventOverflow: {boundariesElement: this.config.boundary}}, onCreate: function (t) {t.originalPlacement! == t.placement && e._handlePopperPlacementChange (t)}, onUpdate: function (t) {return e._handlePopperPlacementChange (t)}}), g (o) .addClass (Fe) , "ontouchstart" em document.documentElement && g (document.body) .children (). on ("mouseover", nulo, g.noop); var c = function () {e.config.animation && e._fixTransition (); var = e._hoverState; e._hoverState = null, g (e.element) .trigger (e.constructor.Event.SHOWN), t === Ele && e._leave (null, e)}; if (g (this.tip) ) .hasClass (xe)) {var h = _.getTransitionDurationFromElement (this.tip); g (this.tip) .one (_. TRANSITION_END, c) .emulateTransitionEnd (h)} mais c ()}}, t.hide = function (t) {var e = isto, n = this.getTipElement (), i = g.Event (this.constructor.Event.HIDE), o = function () {e._hoverState! == je && n.parentNode && n.parentNode.removeChild (n), e._cleanTipClass () , e.element.removeAttribute ("aria-describedby"), g (e.element) .trigger (e.constructor.Event.HIDDEN), null! == e._popper && e._popper.destroy (), t && t ()} ; if (g (this.element) .trigger (i),! i.isDefaultPrevented ()) {if (g (n) .removeClass (Fe), "ontouchstart" em document.documentElement && g (document.body) .children ( ) .off ("mouseover", null, g.noop), this._activeTrigger [Ke] =! 1, this._activeTrigger [Eu] =! 1, this._activeTrigger [qe] =! 1, g (this.tip ) .hasClass (xe)) {var r = _. getTransitionDurationFromElement (n); g (n) .one (_.TRANSITION_END, o) .emulateTransitionEnd (r)} mais o (); this._hoverState = ""}}, t.update = function () {null! == this._popper && this._popper.scheduleUpdate ()}, t.isWithContent = function () {return Booleano (this.getTitle ())}, t.addAttachmentClass = função (t) {g (this.getTipElement ()). addClass (Ae + "-" + t)}, t.getTipElement = função () {return this.tip = this.tip || g (this.config.template) [0], this.tip}, t.setContent = função () {var t = this.getTipElement (); this.setElementContent (g (t.querySelectorAll (Ue)), this.getTitle ()), g (t) .removeClass (xe + "+ Fe)}, t.setElementContent = função (t, e) {" objeto "! = typeof e ||! e.nodeType &&! e.jquery? this.config.html? (this.config.sanitize && (e = Se (e, this.config.whiteList, this.config.sanitizeFn)), t.html (e )): t.text (e): this.config.html? g (e) .parent () .é (t) || t.empty () .endend (e): t.text (g (e) .text ())}, t.getTitle = function () {var t = this.element.getAttribute ("data-original-title"); retorna t || (t = "function" == tipo de this.config.title? this.config.title.call (this.element): this.config.title), t}, t._getOffset = function () {var e = isto, t = {}; retorno "função" == tipo de this.config.offset? t.fn = function (t) {retorno t.offsets = l ({}, t.offsets, e.config.offset (t.offsets, e.element) || {}), t}: t.offset = this.config .offset, t}, t._getContainer = function () {retorno! 1 === this.config.container? document.body: _. isElement (this.config.container)? g (this.config.container): g (document) .find (this.config.container)}, t._getAttachment = função (t) {return Pe [t.toUpperCase ()]}, t._setListeners = function () {var i = isso; config.trigger.split ("") .forEach (function (t) {if ("clique" === t) g (i.element) .on (i.constructor.Event.CLICK, i.config.selector, função (t) {return i.toggle (t)}); else if (t! == Qe) {var e = t === qe? i.constructor.Event.MOUSEENTER: i.constructor.Event.FOCUSIN, n = t === qe? i.constructor.Event.MOUSELEAVE: i.constructor.Event.FOCUSOUT; g (i.element) .on (e, i.config.selector, função (t) {retorno i.enter (t)}). n, i.config.selector, função (t) {retorno i._leave (t)})}}), g (this.element) .closest (". modal"). on ("hide.bs.modal" , function () {i.element && i.hide ()}), this.config.selector? this.config = l ({}, this.config, {trigger: "manual", seletor: ""}): isto. _fixTitle ()}, t._fixTitle = function () {var t = tipo de this.element.getAttribute ("data-original-title"); (this.element.getAttribute ("title") || "string"! = t) && (this.element.setAttribute ("data-original-title", this.element.getAttribute ("title") || ""), this.element.setAttribute ("title "," "))}, t._enter = function (t, e) {var n = this.constructor.DATA_KEY; (e = e || g (t.currentTarget) .data (n)) || ( e = new this.constructor (t.currentTarget, this._getDelegateConfig ()), g (t.currentTarget) .data (n, e)), t && (e._activeTrigger ["focusin" === t.type? Me : qe] =! 0), g (e.getTipElement ()). hasClass (Fe) || e._hoverState === je? e._hoverState = je: (clearTimeout (e._timeout), e._hoverState = je , e.config.delay && e.config.delay.show? e._timeout = setTimeout (função () {e._hoverState === je && e.show ()}, e.config.delay.show): e.show () }}, t._leave = function (t, e) {var n = this.constructor.DATA_KEY; (e = e || g (t.currentTarget) .data (n)) || (e = new this.constructor (t.currentTarget, this._getDelegateConfig ()), g (t.currentTarget) .data (n, e)), te && (e._activeTrigger ["focusout" === t.type? Me: qe] =! 1 ), e._isWithActiveTrigger () || (clearTimeout (e._timeout), e._hoverState = Ele, e.config.delay && e.config.delay.hide? e._timeout = setTimeout (function () {e._hoverState === Ele && e.hide ()}, e.config.delay.hide): e. hide ())}, t._isWithActiveTrigger = function () {para (var t neste._activeTrigger) if (this._activeTrigger [t]) retorna! 0; retorna! 1}, t._getConfig = function (t) { var e = g (this.element) .data (); retorno Object.keys (e) .forEach (função (t) {- 1! == Oe.indexOf (t) && delete e [t]}), "número "== typeof (t = l ({}, this.constructor.Default, e," objeto "== typeof t && t? t: {})). delay && (t.delay = {show: t.delay, ocultar: t.delay}), "número" == typeof t.title && (t.title = t.title.toString ()), "número" == typeof t.content && (t.content = t.content.toString () ), _. typeCheckConfig (ser, t, this.constructor.DefaultType), t.sanitize && (t.template = Se (t.template, t.whiteList, t.sanitizeFn)), t}, t._getDelegateConfig = function () {var t = {}; if (this.config) para (var e neste.config) this.constructor.Default [e]! == this.config [e] && (t [e] = this.config [e]); return t}, t._cleanTipClass = function () {var t = g (this.getTipElement ()), e = t.attr ("class"). correspondência (Ne); null ! == e && e.length && t.removeClass (e.join (""))}, t._handlePopperPlacementChange = function (t) {var e = t.instance; this.tip = e.popper, this._cleanTipClass (), este .addAttachmentClass (this._getAttachment (t.placement))}, t._fixTransition = function () {var t = this.getTipElement (), e = this.config.animation; null === t.getAttribute ("x- posicionamento ") && (g (t) .removeClass (xe), this.config.animation =! 1, this.hide (), this.show (), this.config.animation = e)}, i._jQueryInterface = function (n) {retornar this.each (function () {var t = g (this) .data (Ie), e = "objeto" == tipoof n && n; if ((t ||!/dispose|hide/.test(n))&&(t||(t=new i (isto, e), g (isto) .data (Ie, t)), "string" == typeof n)) { if ("indefinido" == typeof t [n]) lança novo TypeError ('Nenhum método chamado' + n + '"'); t [n] ()}}}}, s (i, null, [{key : "VERSION", get: function () {retorno "4.3.1"}}, {key: "Default", get: function () {retorno Le}}, {key: "NAME", get: function () {return be}}, {chave: "DATA_KEY", get: function () {retorno Ie}}, {chave: "Evento", get: function () {retorno Re}}, {chave: "EVENT_KEY", obter : function () {return De}}, {chave: "DefaultType", get: function () {retorno ke}}]), i} (); g.fn [ser] = Be._jQueryInterface, g.fn [ be] .Constructor = Be, g.fn [ser] .noConflict = function () {retorno g.fn [ser] = nós, Be._jQueryInterface} var var = "popover", Ye = "bs.popover", ze = "." + Ye, Xe = g.fn [Ve], $ e = "bs-popover",Ge = new RegExp ("(^ | \\ s)" + $ e + "\\ S +", "g"), Je = l ({}, Be.Default, {colocação: "direita", gatilho: "clique ", conteúdo:" ", modelo: '<div class =" popover "role =" tooltip "> <div class =" seta "> </ div> <h3 class =" popover-cabeçalho "> </ h3> < div class = "popover-body"> </ div> </ div> '}), Ze = l ({}, Be.DefaultType, {content: "(string | elemento | função)"}), tn = " fade ", en =" show ", nn =". popover-cabeçalho ", on =". popover-body ", rn = {OCULTAR:" ocultar "+ ze, HIDDEN:" oculto "+ ze, SHOW:" mostrar "+ ze, SHOWN:" mostrada "+ ze, INSERTED:" inserida "+ ze, CLICK:" clique em "+ ze, FOCUSIN:" focusin "+ ze, FOCUSOUT:" focusout "+ ze, MOUSE:" mouseenter "+ Z e,MOUSELEAVE: "mouseleave" + ze}, sn = função (t) {var e, n; função i () {return t.apply (isto, argumentos) || isto} n = t, (e = i) .prototype = Object.create (n.prototype), (e.prototype.constructor = e) .__ proto __ = n; var o = i.prototype; retorno o.isWithContent = function () {return this.getTitle () || isto. _getContent ()}, o.addAttachmentClass = function (t) {g (this.getTipElement ()). addClass ($ e + "-" + t)}, o.getTipElement = function () {retorna this.tip = isto. tip || g (this.config.template) [0], this.tip}, o.setContent = function () {var t = g (this.getTipElement ()); this.setElementContent (t.find (nn)) , this.getTitle ()); var e = this._getContent (); "função" == typeof e && (e = e.call (this.element)), this.setElementContent (t.find (on), e) , t.removeClass (tn + "" + en)}, o._getContent = function () {retornar this.element.getAttribute ("data-content") || this.config.content}, o._cleanTipClass = function () {var t = g (this.getTipElement ()), e = t.attr ("class"). correspondência (Ge); null! == e && 0 <e.length && t.removeClass (e.join ( ""))}, i._jQueryInterface = function (n) {retornar this.each (function () {var t = g (this) .data (Ye), e = "objeto" == typeof n? n: null ; if ((t ||! / dispose | ocultar / .test (n)) && (t || (t = novo i (isto, e), g (isso) .data (Ye, t)), "string "== typeof n)) {if (" indefinido "== typeof t [n]) lançar novo TypeError ('Nenhum método chamado' + n + '"'); t [n] ()}}}}, s (i, null, [{key: "VERSION", obter: function () {return "4.3.1"}}, {key: "Padrão", get: function () {return Je}}, {key: " NAME ", get: function () {return Ve}}, {chave:" DATA_KEY ", get: function () {retorno Ye}}, {key:" Evento ", get: function () {retorno rn}}, {key: "EVENT_KEY", obtenha:function () {return ze}}, {chave: "DefaultType", get: function () {retorno Ze}}]), i} (Seja); g.fn [Ve] = sn._jQueryInterface, g.fn [ Ve] .Constructor = sn, g.fn [Ve] .noConflict = function () {retorno g.fn [Ve] = Xe, sn._jQueryInterface}; var an = "scrollspy", ln = "bs.scrollspy", cn = "." + ln, hn = g.fn [an], un = {deslocamento: 10, método: "auto", alvo: ""}, fn = {deslocamento: "número", método: "string" , target: "(string | elemento)"}, dn = {ATIVAR: "ativar" + cn, SCROLL: "rolar" + cn, LOAD_DATA_API: "carregar" + cn + ". data-api"}, gn = "menu suspenso -item ", _ n =" ativo ", mn = '[dados-espião =" rolar "]', pn =". nav, .list-group ", vn =". nav-link ", yn =". nav -item ", En =". list-group-item ", Cn =". dropdown ", Tn =". dropdown-item ", Sn =".dropdown-toggle ", bn =" deslocamento ", In =" posição ", Dn = função () {função n (t, e) {var n = isso; this._element = t, this._scrollElement =" BODY "= == t.tagName? window: t, this._config = this._getConfig (e), this._selector = this._config.target + "" + vn + "," + this._config.target + "" + En + "," + this._config.target + "" + Tn, this._offsets = [], this._targets = [], this._activeTarget = nulo, this._scrollHeight = 0, g (this._scrollElement) .on (dn.SCROLL, function (t) {return n._process (t)}), this.refresh (), this._process ()} var t = n.prototype; retorno t.refresh = function () {var e = isto, t = this._scrollElement === this._scrollElement.window? bn: In, o = "auto" === this._config.method? t: this._config.method, r = o === Em? this._getScrollTop ( ): 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight (), []. Slice.call (documento.querySelectorAll (this._selector)). map (função (t) {var e, n = _. getSelectorFromElement (t); if (n && (e = document.querySelector (n)), e) {var i = e.getBoundingClientRect (); if (i.width || i.height) return [g (e) [o] (). topo + r, n]} retorna nulo}). filter (função (t) {retorno t}). sort (função (t, e) {return t [0] -e [0]}) forEach (function (t) {e._offsets.push (t [0]), e._targets.push (t [1 })})}, t.dispose = function () {g.removeData (this._element, ln), g (this._scrollElement) .off (cn), this._element = null, this._scrollElement = null, este ._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = nulo, this._scrollHeight = nulo}, t._getConfig = function (t) {if ("string" ! = typeof (t = l ({}, un, "objeto" == typeof t && t? t: {})). target) {var e = g (t.target) .attr ("id"); e | | (e = _. getUID (an), g (t.target) .attr ("id", e)), t.target = "#"+ e} return _.typeCheckConfig (an, t, fn), t}, t._getScrollTop = function () {retornar this._scrollElement === window? this._scrollElement.pageYOffset: this._scrollElement.scrollTop}, t. _getScrollHeight = function () {retornar this._scrollElement.scrollHeight || Math.max (document.body.scrollHeight, document.documentElement.scrollHeight)}, t._getOffsetHeight = function () {retornar this._scrollElement === janela? janela? .innerHeight: this._scrollElement.getBoundingClientRect (). height}, t._process = function () {var t = this._getScrollTop () + this._config.offset, e = this._getScrollHeight (), n = this._config .offset + e-this._getOffsetHeight (); if (this._scrollHeight! == e&& this.refresh (), n <= t) {var i = this._targets [this._targets.length-1]; this._activeTarget ! == i && this._activate (i)} else {if (this._activeTarget && t <this._offsets [0] && 0 <this._offsets [0]) retorna isso._activeTarget = null, void this._clear (); para (var o = this._offsets.length; o -;) {this._activeTarget! == this._targets [o] && t> = this._offsets [o] && ("undefined" == typeof this._offsets [o + 1] || t <this._offsets [o + 1]) && this._activate (this._targets [o])}}}, t._activate = função (e {this._activeTarget = e, this._clear (); var t = this._selector.split (","). map (função (t) {retorno t + '[data-alvo = "' + e + '"] , '+ t +' [href = "'+ e +'"] '}), n = g ([]. slice.call (document.querySelectorAll (t.join (",")))); n.hasClass ( gn)? (n.closest (Cn) .find (Sn) .addClass (_n), n.addClass (_n)): (n.addClass (_n), n.parents (pn) .prev (vn + "," + En) .addClass (_n), n.parents (pn) .prev (yn) .children (vn) .addClass (_n)), g (this._scrollElement) .trigger (dn.ACTIVATE, {relatedTarget: e} )}, t._clear = function () {[]. slice.call (document.querySelectorAll (this._selector)). filter (função (t) {retorno t.classList.contains (_n)}). forEach (function (t) {retorno t.classList.remove (_n)})} , n._jQueryInterface = function (e) {retornar this.each (function () {var t = g (this) .data (ln); if (t || (t = novo n (isso, "objeto" == typeof e && e), g (isto) .data (ln, t)), "string" == typeof e) {if ("indefinido" == typeof t [e]) lançar novo TypeError ('Nenhum método chamado "' + e + '' '); t [e] ()}}}, s (n, nulo, [{chave: "VERSION", get: function () {retorno "4.3.1"}}, {chave: " Padrão ", get: function () {return un}}]), n} (); g (janela) .on (dn.LOAD_DATA_API, function () {para (var t = []. Slice.call (document. querySelectorAll (mn)), e = t.length; e -;) {var n = g (t [e]); Dn._jQueryInterface.call (n, n.data ())}}), g.fn [an] = Dn._jQueryInterface, g.fn [an] .Constructor = Dn, g.fn [an].noConflict = function () {return g.fn [an] = hn, Dn._jQueryInterface}; var wn = "bs.tab", An = "." + wn, Nn = g.fn.tab, On = {OCULTAR : "esconder" + An, HIDDEN: "oculto" + An, SHOW: "mostrar" + An, SHOWN: "mostrado" + An, CLICK_DATA_API: "clique em" + An + ". data-api"}, kn = "suspenso -menu ", Pn =" ativo ", Ln =" desativado ", jn =" fade ", Hn =" mostrar ", Rn =". dropdown ", xn =". nav, grupo.list ", Fn =" .active ", Un ="> li> .ativo ", Wn = '[dados-toggle =" aba "], [dados-toggle =" pílula "], [dados-toggle =" lista "]', qn = ".dropdown-toggle", Mn = "> .dropdown-menu .active", Kn = função () {função i (t) {this._element = t} var t = i.prototipo; retorno t.show = função () {var n = this; if (! (this._element.parentNode && this._element).parentNode.nodeType === Node.ELEMENT_NODE && g (this._element) .hasClass (Pn) || g (this._element) .hasClass (Ln))) {var t, i, e = g (this._element) .closest (xn) [0], o = _. getSelectorFromElement (this._element); if (e) {var r = "UL" === e.nodeName || "OL" === e.nodeName? Un: Fn i = (i = g.makeArray (g (e) .find (r))) [i.length-1]} var s = g.Event (On.HIDE, {relatedTarget: this._element}), um = g.Event (On.SHOW, {relatedTarget: i}); if (i && g (i) .trigger (s), g (this._element) .trigger (a),! a.isDefaultPrevented () &&! s. isDefaultPrevented ()) {o && (t = document.querySelector (o)), this._activate (this._element, e); var l = função () {var t = g.Event (On.HIDDEN, {relatedTarget: n ._element}), e = g.Event (On.SHOWN, {relatedTarget: i}); g (i) .trigger (t), g (n.element) .trigger (e)}; t? this._activate (t, t.parentNode, l): l ()}}}, t.dispose = function () {g.removeData (this._element, wn), this._element = null}, t._activate = função (t, e, n) {var i = isto, o = (! e || "UL"! == e.nodeName && "OL"! == e.nodeName? g (e) .crianças (Fn ): g (e) .find (Un)) [0], r = n && o && g (o) .hasClass (jn), s = função () {retorno i._transitionComplete (t, o, n)}; if (o && r ) {var a = _. getTransitionDurationFromElement (o); g (o) .removeClass (Hn) .one (_. TRANSITION_END, s) .emulateTransitionEnd (a)} else s ()}, t._transitionComplete = function (t, e, n) {se (e) {g (e) .removeClass (Pn); var i = g (e.parentNode) .find (Mn) [0]; i && g (i) .removeClass (Pn), "tabulação "=== e.getAttribute (" role ") && e.setAttribute (" aria-selected ",! 1)} se (g (t) .addClass (Pn)," tab "=== t.getAttribute (" função ") && t.setAttribute (" aria-selecionado ",! 0), _. reflow (t), t.classList.contains (jn) && t.classList.add (Hn), t.parentNode && g (t.parentNode).hasClass (kn)) {var o = g (t). mais próximo (Rn) [0]; se (o) {var r = []. slice.call (o.querySelectorAll (qn)); g (r). addClass (Pn)} t.setAttribute ("aria-expandido",! 0)} n && n ()}, i._jQueryInterface = função (n) {retornar this.each (function () {var t = g (this), e = t.data (wn); if (e || (e = new i (this), t.data (wn, e)), "string" == typeof n) {if ("indefinido" == typeof e [n]) lançar novo TypeError ('Nenhum método chamado' + n + '' '); e [n] ()}}}}, s (i, nulo, [{chave: "VERSION", get: function () {return "4.3.1"}}]), i} (); g (documento) .on (On.CLICK_DATA_API, Wn, função (t) {t.preventDefault (), Kn._jQueryInterface.call (g (this), "show")}), g.fn.tab = Kn._jQueryInterface, g.fn.tab.Constructor = Kn, g.fn.tab.noConflict = function () {retorno g.fn.tab = Nn, Kn._jQueryInterface}; var Qn = "toast", Bn = "bs.toast", Vn = "." + Bn, Yn = g.fn [Qn],zn = {CLICK_DISMISS: "click.dismiss" + Vn, ESCONDER: "ocultar" + Vn, HIDDEN: "oculto" + Vn, SHOW: "mostrar" + Vn, MOSTRADO: "mostrado" + Vn}, Xn = "desaparecer ", $ n =" ocultar ", Gn =" mostrar ", Jn =" mostrar ", Zn = {animação:" booleano ", autohide:" booleano ", atraso:" número "}, ti = {animação:! 0 , autohide:! 0, delay: 500}, ei = '[data-dismiss = "torrar"]', ni = function () {função i (t, e) {this._element = t, this._config = esta ._getConfig (e), this._timeout = null, this._setListeners ()} var t = i.prototype; retorno t.show = function () {var t = isso; g (this._element) .trigger (zn. SHOW), this._config.animation && this._element.classList.add (Xn); var e = função () {t._element.classList.remove (Jn), t._element.classList.add (Gn), g (t ._element) .trigger (zn.SHOWN), t._config.autohide && t.hide ()}, se (this._element.classList.remove ($ n), this._element.classList.add (Jn), this._config.animation) {var n = _. getTransitionDurationFromElement (this._element); g (this._element) .one (_. TRANSITION_END, e ) .emulateTransitionEnd (n)} else e ()}, t.hide = function (t) {var e = this; this._element.classList.contains (Gn) && (g (this._element) .trigger (zn. ESCONDER), t this._close (): this._timeout = setTimeout (function () {e._close ()}, this._config.delay))}, t.dispose = function () {clearTimeout (this._timeout ), this._timeout = null, this._element.classList.contains (Gn) && this._element.classL
// # sourceMappingURL = bootstrap.min.js.map
